package com.balaji.projecteuler.solution;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;

/**
 * How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100
 * and 2 ≤ b ≤ 100?
 * 
 * @author Balaji Rayakota (br029281)
 */
public class Problem_29_DistinctPowers {
	/**
	 * Solution = 9183.
	 * 
	 * @param args
	 *           The String array with command line arguments.
	 */
	public static void main(final String[] args) {
		final Set<Number> distinctTerms = new HashSet<>();

		for (int a = 2; a <= 100; a++) {
			for (int b = 2; b <= 100; b++) {
				final Number power = new Number(a).powerOf(b);
				distinctTerms.add(power);
			}
		}
		System.out.println("Distinct powers = " + distinctTerms.size());
	}

	/**
	 * Class which stores a number by storing its prime factors.
	 */
	public static class Number {
		private final Map<Integer, Integer> primeFactors;

		/**
		 * Constructor to create {@link Number} representation of an integer.
		 * 
		 * @param n
		 *           The number to be stored (must be greater than 1).
		 */
		public Number(final int n) {
			if (n < 2) {
				throw new IllegalArgumentException("Number shoulde be at least 2. n = " + n);
			}

			primeFactors = new HashMap<>();
			int copy = n;
			int index = 2;
			while (copy != 1) {
				if (copy % index == 0) {
					while (copy % index == 0) {
						final int existingPower = primeFactors.get(index) == null ? 0 : primeFactors.get(index);
						primeFactors.put(index, existingPower + 1);
						copy /= index;
					}
				}
				index++;
			}
		}

		/**
		 * Constructor to create a {@link Number} from a Map of Integer prime factors
		 * and the power.
		 * 
		 * @param primeFactors
		 *           The Map of Integer prime number and the Integer power representing
		 *           a number.
		 */
		public Number(final Map<Integer, Integer> primeFactors) {
			this.primeFactors = primeFactors;
		}

		@Override
		public String toString() {
			return primeFactors.toString();
		}

		@Override
		public boolean equals(final Object o) {
			if (o == null || !(o instanceof Number)) {
				return false;
			}

			final Map<Integer, Integer> compareMap = ((Number) o).getPrimeFactors();

			return primeFactors.equals(compareMap);
		}

		@Override
		public int hashCode() {
			return Objects.hash(primeFactors);
		}

		/**
		 * Getter for primeFactors.
		 * 
		 * @return A non-null Map of Integer power keyed by the Integer prime number.
		 */
		public Map<Integer, Integer> getPrimeFactors() {
			return primeFactors;
		}

		/**
		 * Creates a {@link Number} which results from raising the current
		 * {@link Number} to the supplied power.
		 * 
		 * @param pow
		 *           The integer power to be raised to.
		 * @return A non-null {@link Number}.
		 */
		public Number powerOf(final int pow) {
			final Map<Integer, Integer> powerPrimeFactor = new HashMap<>(primeFactors.size());

			for (final Entry<Integer, Integer> entry : primeFactors.entrySet()) {
				powerPrimeFactor.put(entry.getKey(), entry.getValue() * pow);
			}

			return new Number(powerPrimeFactor);
		}
	}
}
